8366a47d76f37eb5b00fa07a79960434c78b1ed8
Author: Jan Synacek <jsynacek@redhat.com>
Date:   Wed Jan 8 15:01:37 2014 +0100

    logicalfile: replace thread-unsafe functions

    Some functions, such as readdir() and dirname(), are not
    thread-safe. Use equivalent glib functions.

    trac: #173

2 files changed, 100 insertions(+), 81 deletions(-)
 .../LMI_DirectoryContainsFileProvider.c            | 171 +++++++++++----------
 src/logicalfile/LMI_UnixDirectoryProvider.c        |  10 +-

diff --git a/src/logicalfile/LMI_DirectoryContainsFileProvider.c b/src/logicalfile/LMI_DirectoryContainsFileProvider.c
index 6e1ddc5..06810b7 100644
--- a/src/logicalfile/LMI_DirectoryContainsFileProvider.c
+++ b/src/logicalfile/LMI_DirectoryContainsFileProvider.c
@@ -19,4 +19,5 @@
  */
 #include <konkret/konkret.h>
+#include <glib.h>
 #include "LMI_DirectoryContainsFile.h"
 #include "LMI_UnixDirectory.h"
@@ -32,4 +33,45 @@ static const CMPIBroker* _cb;
 const unsigned int MAX_REFS = 4096;
 
+static CMPIStatus logicalfile_objectpath_from_path(
+    const char *abspath,
+    const char *resultClass,
+    const char *namespace,
+    CMPIObjectPath **o)
+{
+    struct stat sb;
+    CMPIStatus st = {.rc = CMPI_RC_OK};
+
+    char fileclass[BUFLEN];
+    char *fsname;
+    char *fsclassname;
+
+    if (lstat(abspath, &sb) < 0) {
+        char err[BUFLEN];
+        snprintf(err, BUFLEN, "Can't stat file: %s", abspath);
+        CMReturnWithChars(_cb, CMPI_RC_ERR_NOT_FOUND, err);
+    } else {
+        get_class_from_stat(&sb, fileclass);
+        st = check_assoc_class(_cb, namespace, resultClass, fileclass);
+        if (st.rc == RC_ERR_CLASS_CHECK_FAILED) {
+            st.rc = CMPI_RC_OK;
+            *o = NULL;
+            return st;
+        }
+        /* check status again for other possible errors */
+        check_status(st);
+
+        st = get_fsinfo_from_stat(_cb, &sb, abspath, &fsclassname, &fsname);
+        check_status(st);
+    }
+
+    CIM_LogicalFileRef cim_lfr;
+    CIM_LogicalFileRef_Init(&cim_lfr, _cb, namespace);
+    fill_logicalfile(CIM_LogicalFileRef, &cim_lfr, abspath, fsclassname, fsname, fileclass);
+    *o = CIM_LogicalFileRef_ToObjectPath(&cim_lfr, &st);
+    CMSetClassName(*o, fileclass);
+
+    return st;
+}
+
 static CMPIStatus dir_file_objectpaths(
     const CMPIContext* cc,
@@ -44,80 +86,54 @@ static CMPIStatus dir_file_objectpaths(
     unsigned int *count)
 {
-    CMPIObjectPath *o;
+    CMPIObjectPath *o = NULL;
     CMPIStatus st = {.rc = CMPI_RC_OK};
     unsigned int i = 0;
 
-    struct stat sb;
-    struct dirent *de;
-    DIR *dp;
-    dp = opendir(path);
-    if (dp == NULL) {
-      st.rc = CMPI_RC_ERR_NOT_FOUND;
-      return st;
-    }
-    while ((de = readdir(dp))) {
-        if (strcmp(de->d_name, ".") == 0) {
-            continue;
-        }
+    GError *gerror = NULL;
+    GDir *gdir;
+    const gchar *gde;
 
-        char rpath[BUFLEN + 1]; /* \0 */
-        char fileclass[BUFLEN];
-        char *fsname;
-        char *fsclassname;
+    gdir = g_dir_open(path, 0, &gerror);
+    if (gerror) {
+        st.rc = CMPI_RC_ERR_NOT_FOUND;
+        return st;
+    }
 
-        if (strcmp(de->d_name, "..") == 0) {
-            /* to get the parent directory, if either role or result role is
-             * set, role must be GroupComponent, or result role must be
-             * PartComponent */
-            if (group == 1 || rgroup == 0) {
-                continue;
-            }
-            char *aux = strdup(path);
-            strncpy(rpath, dirname(aux), BUFLEN);
-            free(aux);
-        } else {
-            /* to get the content of a directory, if either role or result role
-             * is set, role must be PartComponent, or result role must be
-             * GroupComponent */
-            if (group == 0 || rgroup == 1) {
-                continue;
-            }
-            snprintf(rpath, BUFLEN, "%s/%s",
-                     (strcmp(path, "/") == 0) ? "" : path,
-                     de->d_name);
+    /* since g_dir_read_name() doesn't go over '.' and '..', get the parent first */
+    /* to get the parent directory, if either role or result role is set, role
+     * must be GroupComponent, or result role must be PartComponent */
+    if (!(group == 1 || rgroup == 0)) {
+        gchar *dirname;
+        dirname = g_path_get_dirname(path);
+        st = logicalfile_objectpath_from_path(dirname, resultClass, namespace, &o);
+        g_free(dirname);
+        check_status(st);
+        if (o) {
+            ops[i++] = o;
         }
+    }
 
-        if (lstat(rpath, &sb) < 0) {
-            closedir(dp);
-            char err[BUFLEN];
-            snprintf(err, BUFLEN, "Can't stat file: %s", rpath);
-            CMReturnWithChars(_cb, CMPI_RC_ERR_NOT_FOUND, err);
-        } else {
-            get_class_from_stat(&sb, fileclass);
-            st = check_assoc_class(_cb, namespace, resultClass, fileclass);
-            if (st.rc == RC_ERR_CLASS_CHECK_FAILED) {
-                st.rc = CMPI_RC_OK;
-                continue;
-            } else if (st.rc != CMPI_RC_OK) {
-                goto done;
-            }
-            st = get_fsinfo_from_stat(_cb, &sb, rpath, &fsclassname, &fsname);
-            if (st.rc != CMPI_RC_OK) {
-                goto done;
-            }
+    while ((gde = g_dir_read_name(gdir))) {
+        /* to get the content of a directory, if either role or result role
+         * is set, role must be PartComponent, or result role must be
+         * GroupComponent */
+        if (group == 0 || rgroup == 1) {
+            continue;
         }
 
-        CIM_LogicalFileRef cim_lfr;
-        CIM_LogicalFileRef_Init(&cim_lfr, _cb, namespace);
-        fill_logicalfile(CIM_LogicalFileRef, &cim_lfr, rpath, fsclassname, fsname, fileclass);
-        o = CIM_LogicalFileRef_ToObjectPath(&cim_lfr, &st);
-        CMSetClassName(o, fileclass);
+        gchar *rpath = g_build_filename(path, gde, NULL);
+        st = logicalfile_objectpath_from_path(rpath, resultClass, namespace, &o);
+        g_free(rpath);
 
-        ops[i++] = o;
-        free(fsname);
+        if (st.rc != CMPI_RC_OK) {
+            break;
+        }
+        if (o) {
+            ops[i++] = o;
+        }
     }
     *count = i;
-done:
-    closedir(dp);
+
+    g_dir_close(gdir);
     return st;
 }
@@ -216,16 +232,14 @@ static CMPIStatus associators(
         CIM_DirectoryRef lmi_dr;
         CIM_DirectoryRef_Init(&lmi_dr, _cb, ns);
-        char *aux = strdup(path);
-        char *dir = dirname(aux);
+
         char *fsname;
         char *fsclassname;
 
         st = get_fsinfo_from_path(_cb, path, &fsclassname, &fsname);
-        if (st.rc != CMPI_RC_OK) {
-            free(aux);
-            return st;
-        }
+        check_status(st);
 
-        fill_logicalfile(CIM_DirectoryRef, &lmi_dr, dir, fsclassname, fsname, LMI_UnixDirectory_ClassName);
+        gchar *dirname = g_path_get_dirname(path);
+        fill_logicalfile(CIM_DirectoryRef, &lmi_dr, dirname, fsclassname, fsname, LMI_UnixDirectory_ClassName);
+        g_free(dirname);
         o = CIM_DirectoryRef_ToObjectPath(&lmi_dr, &st);
         CMSetClassName(o, LMI_UnixDirectory_ClassName);
@@ -237,5 +251,4 @@ static CMPIStatus associators(
             CMReturnInstance(cr, ci);
         }
-        free(aux);
         free(fsname);
     } else {
@@ -305,5 +318,5 @@ static CMPIStatus references(
         /* PartComponent */
         CMPIObjectPath *refs[MAX_REFS];
-        unsigned int count;
+        unsigned int count = 0;
         st = dir_file_objectpaths(cc, cr, NULL, group, -1, properties, ns, path, refs, &count);
         check_status(st);
@@ -343,13 +356,12 @@ static CMPIStatus references(
 
         /* GroupComponent */
-        char *aux = strdup(path);
-        char *dir = dirname(aux);
-        st = get_fsinfo_from_path(_cb, dir, &fsclassname, &fsname);
+        gchar *dirname = g_path_get_dirname(path);
+        st = get_fsinfo_from_path(_cb, dirname, &fsclassname, &fsname);
         if (st.rc != CMPI_RC_OK) {
-            free(aux);
+            g_free(dirname);
             return st;
         }
 
-        fill_logicalfile(CIM_DirectoryRef, &lmi_dr, dir, fsclassname, fsname, LMI_UnixDirectory_ClassName);
+        fill_logicalfile(CIM_DirectoryRef, &lmi_dr, dirname, fsclassname, fsname, LMI_UnixDirectory_ClassName);
         o = CIM_DirectoryRef_ToObjectPath(&lmi_dr, &st);
         CMSetClassName(o, LMI_UnixDirectory_ClassName);
@@ -362,5 +374,5 @@ static CMPIStatus references(
             CMReturnInstance(cr, ci);
         }
-        free(aux);
+        g_free(dirname);
     } else {
         /* this association does not associate with given 'cop' class */
@@ -537,3 +549,4 @@ KONKRET_REGISTRATION(
 /* Local Variables: */
 /* indent-tabs-mode: nil */
+/* c-basic-offset: 4 */
 /* End: */
diff --git a/src/logicalfile/LMI_UnixDirectoryProvider.c b/src/logicalfile/LMI_UnixDirectoryProvider.c
index af4be57..f6b0e24 100644
--- a/src/logicalfile/LMI_UnixDirectoryProvider.c
+++ b/src/logicalfile/LMI_UnixDirectoryProvider.c
@@ -94,5 +94,8 @@ static CMPIStatus LMI_UnixDirectoryCreateInstance(
     if (mkdir(path, 0777) < 0) {
         char errmsg[BUFLEN];
-        snprintf(errmsg, BUFLEN, "Can't mkdir: %s (%s)", path, strerror(errno));
+        char strerr[BUFLEN];
+        snprintf(errmsg, BUFLEN, "Can't mkdir: %s (%s)",
+                 path,
+                 strerror_r(errno, strerr, BUFLEN));
         CMReturnWithChars(_cb, CMPI_RC_ERR_FAILED, errmsg);
     }
@@ -122,5 +125,8 @@ static CMPIStatus LMI_UnixDirectoryDeleteInstance(
     if (rmdir(path) < 0) {
         char errmsg[BUFLEN];
-        snprintf(errmsg, BUFLEN, "Can't rmdir: %s (%s)", path, strerror(errno));
+        char strerr[BUFLEN];
+        snprintf(errmsg, BUFLEN, "Can't rmdir: %s (%s)",
+                 path,
+                 strerror_r(errno, strerr, BUFLEN));
         CMReturnWithChars(_cb, CMPI_RC_ERR_FAILED, errmsg);
     }

[back]
